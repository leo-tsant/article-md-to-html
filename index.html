<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to Elementor HTML Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .converter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .input-section, .output-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #e1e1e1;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .output-html {
            background: #f8f9fa;
            border: 2px solid #e1e1e1;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            height: 300px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #28a745;
            color: white;
        }

        .btn-secondary:hover {
            background: #218838;
        }


        @media (max-width: 768px) {
            .converter-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Markdown ‚Üí Elementor HTML Converter</h1>
            <p>Convert markdown to pixel-perfect Elementor HTML with gradient styling</p>
        </div>

        <div class="converter-grid">
            <div class="input-section">
                <h2 class="section-title">üìù Markdown Input</h2>
                <textarea id="markdownInput" placeholder="Enter your markdown here...

# Main Heading (H1)

This is a regular paragraph with some text content.

## Sub Heading (H2)

### Section 5: Setup Reality: 15-30 Minutes, Not Days {#section-5}

Another paragraph here.

### Smaller Heading (H3)
#### Even Smaller (H4)
##### Very Small (H5)
###### Tiny Heading (H6)

---

> This is a blockquote
> It can span multiple lines

- Bullet point one with **bold text**
- Bullet point two with *italic text*
- Bullet point three

1. Numbered list item one
2. Numbered list item two
3. Numbered list item three

| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |

[Jump to Section 5](#section-5)
[Jump to Main Heading](#main-heading-h1)
[External Link](https://example.com)

**Bold text** and *italic text* are supported!"></textarea>
            </div>

            <div class="output-section">
                <h2 class="section-title">üé® Elementor HTML Output</h2>
                <div id="htmlOutput" class="output-html"></div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn btn-primary" onclick="convertToElementorHTML()">
                üîÑ Convert to Elementor HTML
            </button>
            <button class="btn btn-secondary" onclick="copyHTML(this)">
                üìã Copy HTML
            </button>
        </div>
    </div>

    <script>
        // Your exact Elementor CSS variables and styling
        const elementorCSS = `
        :root {
            --e-global-color-primary: #D1D1D1;
            --e-global-color-secondary: #040404;
            --e-global-color-text: #8B8B8B;
            --e-global-color-accent: #FFFFFF;
            --e-global-color-e850821: #753EF7;
            --e-global-color-bcf4dba: #753EF7;
            --e-global-color-147d839: #5A2DB8;
            --e-global-typography-primary-font-family: "Plus Jakarta Sans";
            --e-global-typography-primary-font-weight: 600;
            --e-global-typography-text-font-family: "Plus Jakarta Sans";
            --e-global-typography-text-font-weight: 500;
            --e-global-typography-text-line-height: 1.6em;
            --e-global-typography-c998942-font-family: "Plus Jakarta Sans";
            --e-global-typography-c998942-font-weight: 700;
            --e-global-typography-c998942-line-height: 1.2em;
            --e-global-typography-be2a21e-font-family: "Plus Jakarta Sans";
            --e-global-typography-be2a21e-font-weight: 700;
            --e-global-typography-be2a21e-line-height: 1.2em;
        }
        
        .elementor-element {
            box-sizing: border-box;
            position: relative;
            transition: background .3s,border .3s,border-radius .3s,box-shadow .3s,transform .4s;
        }
        
        .elementor-widget {
            text-align: left;
        }
        
        .elementor-heading-title {
            font-family: var(--e-global-typography-primary-font-family), Sans-serif;
            font-weight: var(--e-global-typography-primary-font-weight);
            background: linear-gradient(90deg, #FFFFFF 0%, transparent 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            max-width: 100%;
            margin: 0;
        }
        
        .elementor-widget-heading h1 {
            font-size: 56px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h2 {
            font-size: 38px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h3 {
            font-size: 24px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h4 {
            font-size: 20px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h5 {
            font-size: 18px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h6 {
            font-size: 16px;
            line-height: 1.2em;
        }
        
        .elementor-text-editor {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            line-height: var(--e-global-typography-text-line-height);
            color: #FFFFFF;
        }
        
        .elementor-align-left {
            text-align: left;
        }
        
        .elementor-icon-list--layout-traditional .elementor-icon-list-item {
            display: flex;
            align-items: center;
        }
        
        .elementor-list-item-link-full_width a {
            width: 100%;
        }
        
        .elementor-icon-list-items {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .elementor-icon-list-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .elementor-icon-list-item a {
            display: flex;
            align-items: center;
            text-decoration: none;
            width: 100%;
        }
        
        .elementor-icon-list-icon {
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .elementor-icon-list-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--e-global-color-e850821);
        }
        
        .e-font-icon-svg {
            display: inline-block;
            font-style: normal;
            font-variant: normal;
            text-rendering: auto;
            line-height: 1;
        }
        
        .elementor-icon-list-text {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            color: #FFFFFF;
            font-size: var(--e-global-typography-text-font-size);
            line-height: 1.3em;
        }
        
        /* Card-style bullet list container with gradient background and dark inner containers */
        .bullet-list-container {
            --radius: 25px;  /* base corner radius */
            --ring-w: 2.5px;   /* gradient ring thickness */
            --base-bw: 1px;  /* base border width */
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            /* thin grey wrapper line that remains visible */
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        /* Individual bullet list items with solid dark backgrounds matching bulletlist.html */
        .bullet-list-container .elementor-icon-list-item {
            background-color: #000000;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

    .bullet-list-container::before {
        content: "";
        position: absolute;
        /* place the gradient ring outside the base border */
        inset: calc(-1 * var(--ring-w));
        padding: var(--ring-w);
        border-radius: calc(var(--radius) + var(--ring-w));
        display: block;
        /* Softer purple that fades earlier, matching TOC */
        background: linear-gradient(
        to bottom,
        rgba(117, 62, 247, 0.60) 0%,
        rgba(168, 85, 247, 0.40) 16%,
        rgba(168, 85, 247, 0.20) 32%,
        rgba(168, 85, 247, 0.00) 55%
        );
        /* Mask the center so only the ring shows */
        -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
        -webkit-mask-composite: xor;
            mask-composite: exclude;
        /* be above the thin base border but not capture events */
        z-index: 1;
        pointer-events: none;
    }

        /* Fallback for browsers without mask-composite: keep subtle wrapper line only */
        @supports not (mask-composite: exclude) {
            .bullet-list-container::before,
            .table-container::before,
            .numbered-list-container::before { content: none; }
            /* borders defined on the containers remain as the visible wrappers */
        }
        
        /* Blockquote styling */
        .elementor-blockquote {
            border-left: 4px solid var(--e-global-color-e850821);
            padding: 20px;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: #FFFFFF;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
        }
        
        /* Table container with gradient background matching bullet/numbered lists */
        .table-container {
            --radius: 25px;
            --ring-w: 2.5px;
            --base-bw: 1px;
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        .table-container::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            z-index: 1;
            pointer-events: none;
        }
        
        .elementor-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            background: transparent;
            border: none;
            border-radius: 0;
            overflow: hidden;
        }
        
        .elementor-table th,
        .elementor-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
        }
        
        .elementor-table th {
            background: rgba(117, 62, 247, 0.1);
            font-weight: 700;
            color: var(--e-global-color-accent);
        }
        
        .elementor-table tr:last-child td {
            border-bottom: none;
        }
        
        /* Card-style numbered list container with gradient background and dark inner containers */
        .numbered-list-container {
            --radius: 25px;
            --ring-w: 2.5px;
            --base-bw: 1px;
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        /* Individual numbered list items with solid dark backgrounds matching bulletlist.html */
        .numbered-list-container .elementor-numbered-list-item {
            background-color: #000000;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .numbered-list-container::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            z-index: 1;
            pointer-events: none;
        }
        
        .elementor-numbered-list {
            list-style: none;
            counter-reset: item-counter;
            padding: 0;
            margin: 0;
        }
        
        .elementor-numbered-list-item {
            counter-increment: item-counter;
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            position: relative;
        }
        
        .elementor-numbered-list-item::before {
            content: counter(item-counter);
            background: var(--e-global-color-e850821);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            margin-right: 15px;
            flex-shrink: 0;
            margin-top: 2px;
        }
        
        .elementor-numbered-list-text {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            color: #FFFFFF;
            font-size: var(--e-global-typography-text-font-size);
            line-height: 1.3em;
        }
        
        /* Horizontal rule styling */
        .elementor-divider {
            margin: 30px 0;
            border: none;
            height: 2px;
            background: linear-gradient(90deg, var(--e-global-color-e850821) 0%, rgba(117, 62, 247, 0.3) 100%);
            border-radius: 2px;
        }
        
        /* Directory tree styling */
        .directory-tree-container {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            font-family: 'Courier New', monospace;
        }
        
        .directory-tree {
            color: #FFFFFF;
            line-height: 1.6;
            white-space: pre;
            font-size: 14px;
        }
        
        .directory-tree .folder {
            color: #FFD700;
            font-weight: 600;
        }
        
        .directory-tree .file {
            color: #87CEEB;
        }
        
        .directory-tree .comment {
            color: #90EE90;
            font-style: italic;
        }
        
        /* Code block styling */
        .code-block-container {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .code-block-header {
            background: rgba(117, 62, 247, 0.2);
            padding: 8px 15px;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-size: 12px;
            color: #CCCCCC;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .code-block-content {
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: #FFFFFF;
            white-space: pre;
            overflow-x: auto;
            background: rgba(0, 0, 0, 0.2);
        }
        
        /* Inline code styling */
        .inline-code {
            background-color: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #FFFFFF;
        }
        `;

        // Generate unique Elementor IDs
        function generateElementorId() {
            return Math.random().toString(16).substr(2, 8);
        }

        // H1 with gradient styling
        function createH1Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h1 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h1>
</div>`;
        }

        // H2 with same gradient styling as H1
        function createH2Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h2 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h2>
</div>`;
        }

        // H3 with same gradient styling as H1
        function createH3Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h3 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h3>
</div>`;
        }

        // H4 with same gradient styling as H1
        function createH4Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h4 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h4>
</div>`;
        }

        // H5 with same gradient styling as H1
        function createH5Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h5 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h5>
</div>`;
        }

        // H6 with same gradient styling as H1
        function createH6Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h6 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h6>
</div>`;
        }

        // Paragraph structure
        function createParagraphElement(text) {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
    <div class="elementor-widget-container">
        <p class="elementor-text-editor">${text}</p>
    </div>
</div>`;
        }

        // Blockquote structure
        function createBlockquoteElement(text) {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
    <div class="elementor-widget-container">
        <blockquote class="elementor-blockquote">${parseInlineMarkdown(text)}</blockquote>
    </div>
</div>`;
        }

        // Table structure
        function createTableElement(rows) {
            const id = generateElementorId();
            const tableRows = rows.map((row, index) => {
                const cells = row.map(cell => {
                    const tag = index === 0 ? 'th' : 'td';
                    return `<${tag}>${parseInlineMarkdown(cell)}</${tag}>`;
                }).join('');
                return `<tr>${cells}</tr>`;
            }).join('\n            ');
            
            return `<div class="table-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <table class="elementor-table">
                ${tableRows}
            </table>
        </div>
    </div>
</div>`;
        }

        // Horizontal rule structure
        function createHorizontalRuleElement() {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-divider" data-id="${id}" data-element_type="widget" data-widget_type="divider.default">
    <div class="elementor-widget-container">
        <hr class="elementor-divider">
    </div>
</div>`;
        }

        // Directory tree structure
        function createDirectoryTreeElement(treeContent) {
            const id = generateElementorId();
            
            // Parse and format the directory tree
            const formattedTree = formatDirectoryTree(treeContent);
            
            return `<div class="directory-tree-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <div class="directory-tree">${formattedTree}</div>
        </div>
    </div>
</div>`;
        }

        // Format directory tree with proper coloring
        function formatDirectoryTree(content) {
            return content
                .split('\n')
                .map(line => {
                    // Detect folders (ending with /)
                    if (line.match(/.*\/\s*$/)) {
                        return line.replace(/(.*\/)\s*$/, '<span class="folder">$1</span>');
                    }
                    // Detect comments in parentheses
                    else if (line.includes('(') && line.includes(')')) {
                        return line.replace(/(\([^)]*\))/, '<span class="comment">$1</span>');
                    }
                    // Regular files
                    else if (line.trim() && !line.match(/^[‚îú‚îî‚îÇ\s]*$/)) {
                        // Extract the filename part (after tree characters)
                        const match = line.match(/^([‚îú‚îî‚îÇ\s‚îÄ]*)(.*)/);
                        if (match) {
                            return match[1] + '<span class="file">' + match[2] + '</span>';
                        }
                        return '<span class="file">' + line + '</span>';
                    }
                    return line;
                })
                .join('\n');
        }

        // Code block structure
        function createCodeBlockElement(language, content) {
            const id = generateElementorId();
            
            // Check if the content is a directory tree structure
            const hasTreeChars = content.includes('‚îî') || content.includes('‚îú') || content.includes('‚îÇ');
            const hasDirectoryStructure = content.match(/.*\/\s*$|.*\.(js|ts|json|md|txt|py|html|css|xml)/) || content.includes('(') && content.includes(')');
            
            if (hasTreeChars && hasDirectoryStructure) {
                // Render as directory tree instead of code block
                return createDirectoryTreeElement(content);
            }
            
            // Clean up the content - remove extra whitespace but preserve internal spacing
            const cleanContent = content.split('\n')
                .map(line => line.replace(/^\s*/, '')) // Remove leading whitespace
                .join('\n')
                .trim();
            
            const languageLabel = language || 'code';
            
            return `<div class="code-block-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <div class="code-block-header">${languageLabel}</div>
            <div class="code-block-content">${cleanContent}</div>
        </div>
    </div>
</div>`;
        }

        // Numbered list structure
        function createNumberedListElement(items) {
            const id = generateElementorId();
            const listItems = items.map(item => 
                `<li class="elementor-numbered-list-item">
                    <span class="elementor-numbered-list-text">${item}</span>
                </li>`
            ).join('\n                ');
            
            return `<div class="numbered-list-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <ol class="elementor-numbered-list">
                ${listItems}
            </ol>
        </div>
    </div>
</div>`;
        }

        // List structure with check-circle icons (non-clickable)
        function createListElement(items) {
            const id = generateElementorId();
            const listItems = items.map(item => 
                `<li class="elementor-icon-list-item">
                    <span class="elementor-icon-list-icon">
                        <svg aria-hidden="true" class="e-font-icon-svg e-far-check-circle" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 48c110.532 0 200 89.451 200 200 0 110.532-89.451 200-200 200-110.532 0-200-89.451-200-200 0-110.532 89.451-200 200-200m140.204 130.267l-22.536-22.718c-4.667-4.705-12.265-4.736-16.97-.068L215.346 303.697l-59.792-60.277c-4.667-4.705-12.265-4.736-16.97-.069l-22.719 22.536c-4.705 4.667-4.736 12.265-.068 16.971l90.781 91.516c4.667 4.705 12.265 4.736 16.97.068l172.589-171.204c4.704-4.668 4.734-12.266.067-16.971z"></path></svg>
                    </span>
                    <span class="elementor-icon-list-text">${item}</span>
                </li>`
            ).join('\n                ');
            
            return `<div class="bullet-list-container">
    <div class="elementor-element elementor-element-${id} elementor-align-left elementor-icon-list--layout-traditional elementor-widget elementor-widget-icon-list" data-id="${id}" data-element_type="widget" data-widget_type="icon-list.default">
        <ul class="elementor-icon-list-items">
            ${listItems}
        </ul>
    </div>
</div>`;
        }

        function convertToElementorHTML() {
            const markdownInput = document.getElementById('markdownInput').value;
            const htmlOutput = document.getElementById('htmlOutput');

            if (!markdownInput.trim()) {
                htmlOutput.textContent = 'Please enter some markdown content to convert.';
                return;
            }

            try {
                let html = parseMarkdownToElementor(markdownInput);
                
                // Add the CSS
                html = `<style>${elementorCSS}</style>\n\n` + html;
                
                htmlOutput.textContent = html;
                
                // Store for copying
                window.currentHTML = html;

            } catch (error) {
                htmlOutput.textContent = 'Error converting markdown: ' + error.message;
            }
        }

        function parseInlineMarkdown(text) {
            // Parse inline code (`code`)
            text = text.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
            
            // Parse bold text (**text**)
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Parse italic text (*text*)
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Parse internal links for table of contents [text](#anchor)
            text = text.replace(/\[([^\]]+)\]\(#([^)]+)\)/g, '<a href="#$2">$1</a>');
            
            // Parse regular links [text](url)
            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            return text;
        }

        // Generate slug from header text for anchors
        function generateSlug(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .trim();
        }

        function parseMarkdownToElementor(markdown) {
            const lines = markdown.split('\n');
            const result = [];
            let currentList = [];
            let currentNumberedList = [];
            let currentTable = [];
            let inBlockquote = false;
            let blockquoteContent = '';
            let inDirectoryTree = false;
            let directoryTreeContent = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLanguage = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Handle fenced code blocks (```language)
                if (line.startsWith('```')) {
                    if (!inCodeBlock) {
                        // Starting a code block
                        if (currentList.length > 0) {
                            result.push(createListElement(currentList));
                            currentList = [];
                        }
                        if (currentNumberedList.length > 0) {
                            result.push(createNumberedListElement(currentNumberedList));
                            currentNumberedList = [];
                        }
                        if (currentTable.length > 0) {
                            result.push(createTableElement(currentTable));
                            currentTable = [];
                        }
                        
                        inCodeBlock = true;
                        codeBlockLanguage = line.substring(3).trim(); // Extract language after ```
                        codeBlockContent = '';
                        continue;
                    } else {
                        // Ending a code block
                        result.push(createCodeBlockElement(codeBlockLanguage, codeBlockContent));
                        inCodeBlock = false;
                        codeBlockContent = '';
                        codeBlockLanguage = '';
                        continue;
                    }
                }
                
                // If we're inside a code block, collect all content
                if (inCodeBlock) {
                    codeBlockContent += (codeBlockContent ? '\n' : '') + lines[i]; // Use original line with whitespace
                    continue;
                }
                
                // Handle directory tree structures - much more specific detection
                const isDirectoryLine = (line.includes('‚îî') || line.includes('‚îú') || line.includes('‚îÇ')) &&
                                       (line.includes('/') || line.match(/\.(js|ts|json|md|txt|py|html|css|xml)$/)) &&
                                       !line.includes('|') && // Not a table
                                       !line.includes('**') && // Not bold text
                                       !line.includes('`'); // Not code
                
                if (isDirectoryLine && !inDirectoryTree) {
                    // Starting a new directory tree - only start if we detect actual tree characters
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    inDirectoryTree = true;
                    directoryTreeContent = lines[i]; // Use original line with whitespace
                    continue;
                }
                
                if (inDirectoryTree) {
                    // Only continue if line has tree characters OR is indented and has folder/file indicators
                    const hasTreeChars = lines[i].includes('‚îî') || lines[i].includes('‚îú') || lines[i].includes('‚îÇ');
                    const isIndentedPath = lines[i].match(/^\s+.*\/$/) || lines[i].match(/^\s+.*\.(js|ts|json|md|txt|py|html|css|xml)/) || lines[i].match(/^\s+.*\([^)]+\)$/);
                    const continuingTree = hasTreeChars || 
                                          lines[i].trim() === '' || // Allow empty lines in trees
                                          (isIndentedPath && !lines[i].includes('|') && !lines[i].includes('**') && !lines[i].includes('`'));
                    
                    if (continuingTree) {
                        directoryTreeContent += '\n' + lines[i];
                        continue;
                    } else {
                        // End the directory tree
                        result.push(createDirectoryTreeElement(directoryTreeContent));
                        inDirectoryTree = false;
                        directoryTreeContent = '';
                        // Continue processing the current line normally
                    }
                }

                // Handle blockquotes (both "> " and just ">")
                if (line.startsWith('> ') || line.startsWith('>')) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    
                    if (!inBlockquote) {
                        inBlockquote = true;
                        blockquoteContent = '';
                    }
                    
                    // Extract text after > or > 
                    const quoteText = line.startsWith('> ') ? line.substring(2) : line.substring(1);
                    blockquoteContent += (blockquoteContent ? ' ' : '') + quoteText;
                    continue;
                } else if (inBlockquote) {
                    result.push(createBlockquoteElement(blockquoteContent));
                    inBlockquote = false;
                    blockquoteContent = '';
                }
                
                // Handle table rows (skip separator rows like |---|---|)
                if (line.includes('|') && line.split('|').length > 2) {
                    // Skip separator rows that contain only dashes, spaces, and pipes between the outer pipes
                    const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                    const isSeparatorRow = cells.every(cell => /^[\s\-]+$/.test(cell));
                    if (!isSeparatorRow) {
                        if (currentList.length > 0) {
                            result.push(createListElement(currentList));
                            currentList = [];
                        }
                        if (currentNumberedList.length > 0) {
                            result.push(createNumberedListElement(currentNumberedList));
                            currentNumberedList = [];
                        }
                        
                        if (cells.length > 0) {
                            currentTable.push(cells);
                        }
                    }
                    continue;
                } else if (currentTable.length > 0 && !line.includes('|')) {
                    result.push(createTableElement(currentTable));
                    currentTable = [];
                }
                
                // Handle horizontal rules (---)
                if (line.match(/^-{3,}$/)) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    result.push(createHorizontalRuleElement());
                    continue;
                }

                if (!line) {
                    // Process any pending lists or table
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    continue;
                }

                // Headers - Check from most specific (H6) to least specific (H1)
                if (line.match(/^######\s+(.+)$/)) {
                    const match = line.match(/^######\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH6Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^#####\s+(.+)$/)) {
                    const match = line.match(/^#####\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH5Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^####\s+(.+)$/)) {
                    const match = line.match(/^####\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH4Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^###\s+(.+)$/)) {
                    const match = line.match(/^###\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH3Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^##\s+(.+)$/)) {
                    const match = line.match(/^##\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH2Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^#\s+(.+)$/)) {
                    const match = line.match(/^#\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH1Element(parseInlineMarkdown(match[1])));
                    continue;
                }

                // Bullet list items
                const bulletMatch = line.match(/^[-*+]\s+(.+)$/);
                if (bulletMatch) {
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    currentList.push(parseInlineMarkdown(bulletMatch[1]));
                    continue;
                }

                // Numbered list items
                const numberedMatch = line.match(/^\d+\.\s+(.+)$/);
                if (numberedMatch) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    currentNumberedList.push(parseInlineMarkdown(numberedMatch[1]));
                    continue;
                }

                // Regular paragraphs
                if (line) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    
                    result.push(createParagraphElement(parseInlineMarkdown(line)));
                }
            }

            // Process any remaining items
            if (currentList.length > 0) {
                result.push(createListElement(currentList));
            }
            if (currentNumberedList.length > 0) {
                result.push(createNumberedListElement(currentNumberedList));
            }
            if (currentTable.length > 0) {
                result.push(createTableElement(currentTable));
            }
            if (inBlockquote && blockquoteContent) {
                result.push(createBlockquoteElement(blockquoteContent));
            }
            if (inDirectoryTree && directoryTreeContent) {
                result.push(createDirectoryTreeElement(directoryTreeContent));
            }
            if (inCodeBlock && codeBlockContent) {
                result.push(createCodeBlockElement(codeBlockLanguage, codeBlockContent));
            }

            return result.join('\n\n');
        }

        function copyHTML(btn) {
            if (!window.currentHTML) {
                alert('Please convert some markdown first!');
                return;
            }

            navigator.clipboard.writeText(window.currentHTML).then(() => {
                const originalText = btn.textContent;
                const originalBackground = btn.style.background;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#28a745';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = originalBackground;
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        }

        // Auto-convert sample content on load
        window.addEventListener('load', () => {
            convertToElementorHTML();
        });
    </script>
</body>
</html>