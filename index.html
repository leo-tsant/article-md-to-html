<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to Elementor HTML Converter</title>
    <!-- Purple gradient favicon to match the page style -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns%3D%22http%3A//www.w3.org/2000/svg%22 viewBox%3D%220 0 64 64%22%3E%3Cdefs%3E%3ClinearGradient id%3D%22grad%22 x1%3D%220%22 y1%3D%220%22 x2%3D%221%22 y2%3D%221%22%3E%3Cstop offset%3D%220%25%22 stop-color%3D%22%23A855F7%22/%3E%3Cstop offset%3D%22100%25%22 stop-color%3D%22%23753EF7%22/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x%3D%2216%22 y%3D%2216%22 width%3D%2232%22 height%3D%2232%22 rx%3D%228%22 transform%3D%22rotate(45 32 32)%22 fill%3D%22url(%23grad)%22/%3E%3C/svg%3E" />
    <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
            /* Central subtle purple glow fading to darker edges */
            background:
                radial-gradient(1200px circle at 50% 32%, rgba(117, 62, 247, 0.35) 0%, rgba(117, 62, 247, 0.16) 38%, rgba(117, 62, 247, 0.08) 55%, rgba(8, 8, 12, 0.96) 72%, #060608 100%),
                #0a0a0a;
            color: #e5e7eb;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px 20px;
        }

        :root {
            --card-radius: 18px;
            --ring-w: 2.5px;
            --border: rgba(31,31,31,1);
            --card-bg-start: #1F1F1F;
            --card-bg-end: #0E0E0E;
            --accent: #753EF7; /* matches elementor purple */
            --accent-2: #A855F7; /* lighter purple */
        }

        .header {
            color: #e5e7eb;
            padding: 24px;
            border-radius: var(--card-radius);
            margin-bottom: 28px;
            text-align: center;
            position: relative;
            background-image: radial-gradient(at top left, var(--card-bg-start) 0%, var(--card-bg-end) 50%);
            border: 1px solid var(--border);
        }
        .header::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--card-radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            pointer-events: none;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #FFFFFF 0%, rgba(255,255,255,0.7) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .header p { color: #8B8B8B; }

        .converter-grid {
            display: grid;
            grid-template-columns: 1fr; /* single column; output appears below input */
            gap: 24px;
            margin-bottom: 20px;
        }

        .input-section, .output-section {
            position: relative;
            background-image: radial-gradient(at top left, var(--card-bg-start) 0%, var(--card-bg-end) 50%);
            border-radius: var(--card-radius);
            padding: 20px;
            border: 1px solid var(--border);
            overflow: visible;
            min-width: 0; /* allow grid children to shrink without expanding column */
        }
        .input-section::before, .output-section::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--card-radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            pointer-events: none;
        }

        .section-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: #D1D1D1;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        textarea {
            width: 100%;
            height: 56vh;
            min-height: 420px;
            padding: 14px;
            border: 1px solid rgba(255,255,255,0.06);
            background: #000000;
            color: #e5e7eb;
            border-radius: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(117, 62, 247, 0.18);
        }

        .output-html {
            background: #000000;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 14px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            height: 56vh;
            min-height: 420px;
            overflow-y: auto;
            overflow-x: auto; /* prevent layout shift due to long lines */
            overflow-wrap: anywhere; /* allow breaking long tokens */
            word-break: break-word;
            line-height: 1.5;
            color: #e2e8f0;
        }

        .buttons {
            display: flex;
            gap: 12px;
            margin: 16px 0;
            justify-content: flex-end;
        }

    .btn {
            padding: 10px 16px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.15s ease, transform 0.1s ease;
            font-size: 14px;
            border: 1px solid transparent;
        }
    .btn-primary { background: var(--accent); color: #fff; }
    .btn-primary:hover { background: var(--accent-2); transform: translateY(-1px); }
    .btn-secondary { background: transparent; color: #e5e7eb; border-color: rgba(255,255,255,0.08); }
        .btn-secondary:hover { border-color: rgba(255,255,255,0.14); background: #000000; }
        .btn-danger { background: #dc2626; color: #fff; border-color: transparent; }
        .btn-danger:hover { background: #b91c1c; transform: translateY(-1px); }

        /* Dropzone */
        .dropzone {
            position: relative;
            border: 1.5px dashed rgba(117, 62, 247, 0.45);
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(117,62,247,0.05) 0%, rgba(117,62,247,0.03) 100%);
            padding: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }
        .dropzone:hover, .dropzone.dragover {
            border-color: rgba(168, 85, 247, 0.65);
            background: linear-gradient(180deg, rgba(117,62,247,0.08) 0%, rgba(117,62,247,0.05) 100%);
        }
        .dz-icon { width: 28px; height: 28px; display: grid; place-items: center; color: #c4b5fd; }
        .dz-title { font-weight: 600; color: #D1D1D1; }
        .dz-sub { color: #8B8B8B; font-size: 0.9rem; }
    .input-split { height: 56vh; min-height: 420px; display: flex; flex-direction: column; gap: 12px; }
    .input-split .dropzone { flex: 1 1 0; text-align: center; }
    .input-split textarea { flex: 1 1 0; height: auto; min-height: 0; }
    .or-divider { display: flex; align-items: center; gap: 10px; color: #8B8B8B; font-size: 0.85rem; }
    .or-divider::before, .or-divider::after { content: ""; height: 1px; background: rgba(255,255,255,0.12); flex: 1; }

        /* Fallback for browsers without mask-composite: keep subtle wrapper line only */
        @supports not (mask-composite: exclude) {
            .header::before,
            .input-section::before,
            .output-section::before { content: none; }
        }


        /* Responsive column layouts - stack columns on smaller screens */
        @media (max-width: 900px) { .converter-grid { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .converter-grid { grid-template-columns: 1fr; }
            .header h1 { font-size: 1.6rem; }
            /* On tablets and smaller, reduce 3-column to 2-column */
            .bullet-list-container[data-columns="3"] .elementor-icon-list-items,
            .numbered-list-container[data-columns="3"] .elementor-numbered-list {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            /* On phones, force all lists to single column */
            .bullet-list-container[data-columns="2"] .elementor-icon-list-items,
            .bullet-list-container[data-columns="3"] .elementor-icon-list-items,
            .numbered-list-container[data-columns="2"] .elementor-numbered-list,
            .numbered-list-container[data-columns="3"] .elementor-numbered-list {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Markdown → Elementor HTML Converter</h1>
            <p>Convert Markdown to clean, Elementor-ready HTML.</p>
        </div>

        <div class="converter-grid">
            <div class="input-section" id="markdownSection">
                <h2 class="section-title">Markdown Input</h2>
                <div class="input-split">
                    <label class="dropzone" for="mdFile" id="dropzone">
                        <span class="dz-icon" aria-hidden="true">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M20 16.5a4.5 4.5 0 10-2.35-8.35 6 6 0 10-11.3 0A4.5 4.5 0 004 16.5h16z" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/>
                            </svg>
                        </span>
                        <div>
                            <div class="dz-title">Drag & drop your Markdown file</div>
                            <div class="dz-sub">or click to browse (.md, .markdown, .txt)</div>
                        </div>
                        <input id="mdFile" type="file" accept=".md,.markdown,.txt" style="display:none" />
                    </label>
                    <div class="or-divider"><span>OR</span></div>
                    <textarea id="markdownInput" placeholder="## Sample Markdown

Paste or type your content here.

- Bullet one
- Bullet two

> Pro tip: Use code fences (```lang) for blocks.

[Link](https://example.com) and **bold**, *italic*, and `inline code`. "></textarea>
                </div>
            </div>

            <!-- Convert button placed outside and just below the input container -->
            <div class="buttons" id="inputButtons" style="justify-content: flex-end; margin-top:12px;">
                <button class="btn btn-primary" onclick="convertToElementorHTML()">Convert to Elementor HTML</button>
            </div>

            <div class="output-section" id="outputSection" style="display:none;">
                <h2 class="section-title">Elementor HTML Output</h2>
                <div id="htmlOutput" class="output-html"></div>
            </div>

            <!-- Reset and Copy buttons placed outside and just below the output container -->
            <div class="buttons" id="outputButtons" style="justify-content: flex-end; margin-top:12px; display:none;">
                <button id="resetBtn" class="btn btn-danger" style="display:none" onclick="resetOutput()">Reset</button>
                <button class="btn btn-secondary" onclick="copyHTML(this)">Copy HTML</button>
            </div>
        </div>

        
    </div>

    <script>
        // Your exact Elementor CSS variables and styling
        const elementorCSS = `
        :root {
            --e-global-color-primary: #D1D1D1;
            --e-global-color-secondary: #040404;
            --e-global-color-text: #8B8B8B;
            --e-global-color-accent: #FFFFFF;
            --e-global-color-e850821: #753EF7;
            --e-global-color-bcf4dba: #753EF7;
            --e-global-color-147d839: #5A2DB8;
            --e-global-typography-primary-font-family: "Plus Jakarta Sans";
            --e-global-typography-primary-font-weight: 600;
            --e-global-typography-text-font-family: "Plus Jakarta Sans";
            --e-global-typography-text-font-weight: 500;
            --e-global-typography-text-line-height: 1.6em;
            --e-global-typography-c998942-font-family: "Plus Jakarta Sans";
            --e-global-typography-c998942-font-weight: 700;
            --e-global-typography-c998942-line-height: 1.2em;
            --e-global-typography-be2a21e-font-family: "Plus Jakarta Sans";
            --e-global-typography-be2a21e-font-weight: 700;
            --e-global-typography-be2a21e-line-height: 1.2em;
        }
        
        .elementor-element {
            box-sizing: border-box;
            position: relative;
            transition: background .3s,border .3s,border-radius .3s,box-shadow .3s,transform .4s;
        }
        
        .elementor-widget {
            text-align: left;
        }
        
        .elementor-heading-title {
            font-family: var(--e-global-typography-primary-font-family), Sans-serif;
            font-weight: var(--e-global-typography-primary-font-weight);
            background: linear-gradient(90deg, #FFFFFF 0%, transparent 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            max-width: 100%;
            margin: 0;
        }
        
        .elementor-widget-heading h1 {
            font-size: 56px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h2 {
            font-size: 38px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h3 {
            font-size: 24px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h4 {
            font-size: 20px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h5 {
            font-size: 18px;
            line-height: 1.2em;
        }
        
        .elementor-widget-heading h6 {
            font-size: 16px;
            line-height: 1.2em;
        }
        
        .elementor-text-editor {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            line-height: var(--e-global-typography-text-line-height);
            color: #FFFFFF;
        }
        
        .elementor-align-left {
            text-align: left;
        }
        
        .elementor-icon-list--layout-traditional .elementor-icon-list-item {
            display: flex;
            align-items: center;
        }
        
        .elementor-list-item-link-full_width a {
            width: 100%;
        }
        
        .elementor-icon-list-items {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .elementor-icon-list-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .elementor-icon-list-item a {
            display: flex;
            align-items: center;
            text-decoration: none;
            width: 100%;
        }
        
        .elementor-icon-list-icon {
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .elementor-icon-list-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--e-global-color-e850821);
        }
        
        .e-font-icon-svg {
            display: inline-block;
            font-style: normal;
            font-variant: normal;
            text-rendering: auto;
            line-height: 1;
        }
        
        .elementor-icon-list-text {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            color: #FFFFFF;
            font-size: var(--e-global-typography-text-font-size);
            line-height: 1.3em;
        }
        
        /* Card-style bullet list container with gradient background and dark inner containers */
        .bullet-list-container {
            --radius: 25px;  /* base corner radius */
            --ring-w: 2.5px;   /* gradient ring thickness */
            --base-bw: 1px;  /* base border width */
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            /* thin grey wrapper line that remains visible */
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        /* Column layout support for bullet lists */
        .bullet-list-container[data-columns="1"] .elementor-icon-list-items {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .bullet-list-container[data-columns="2"] .elementor-icon-list-items {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
        }

        .bullet-list-container[data-columns="3"] .elementor-icon-list-items {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px 20px;
        }

        /* Individual bullet list items with solid dark backgrounds matching bulletlist.html */
        .bullet-list-container .elementor-icon-list-item {
            background-color: #000000;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Numeric text size configuration for bullet list items */
        .bullet-list-container .elementor-icon-list-text {
            font-size: var(--text-size, 16px);
            line-height: 1.3em;
        }

    .bullet-list-container::before {
        content: "";
        position: absolute;
        /* place the gradient ring outside the base border */
        inset: calc(-1 * var(--ring-w));
        padding: var(--ring-w);
        border-radius: calc(var(--radius) + var(--ring-w));
        display: block;
        /* Softer purple that fades earlier, matching TOC */
        background: linear-gradient(
        to bottom,
        rgba(117, 62, 247, 0.60) 0%,
        rgba(168, 85, 247, 0.40) 16%,
        rgba(168, 85, 247, 0.20) 32%,
        rgba(168, 85, 247, 0.00) 55%
        );
        /* Mask the center so only the ring shows */
        -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
        -webkit-mask-composite: xor;
            mask-composite: exclude;
        /* be above the thin base border but not capture events */
        z-index: 1;
        pointer-events: none;
    }

        /* Fallback for browsers without mask-composite: keep subtle wrapper line only */
        @supports not (mask-composite: exclude) {
            .bullet-list-container::before,
            .table-container::before,
            .numbered-list-container::before { content: none; }
            /* borders defined on the containers remain as the visible wrappers */
        }
        
        /* Blockquote styling */
        .elementor-blockquote {
            border-left: 4px solid var(--e-global-color-e850821);
            padding: 20px;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: #FFFFFF;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
        }
        
        /* Table container with gradient background matching bullet/numbered lists */
        .table-container {
            --radius: 25px;
            --ring-w: 2.5px;
            --base-bw: 1px;
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        .table-container::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            z-index: 1;
            pointer-events: none;
        }
        
        .elementor-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            background: transparent;
            border: none;
            border-radius: 0;
            overflow: hidden;
        }
        
        .elementor-table th,
        .elementor-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
        }
        
        .elementor-table th {
            background: rgba(117, 62, 247, 0.1);
            font-weight: 700;
            color: var(--e-global-color-accent);
        }
        
        .elementor-table tr:last-child td {
            border-bottom: none;
        }
        
        /* Card-style numbered list container with gradient background and dark inner containers */
        .numbered-list-container {
            --radius: 25px;
            --ring-w: 2.5px;
            --base-bw: 1px;
            position: relative;
            box-sizing: border-box;
            border-radius: var(--radius);
            border: var(--base-bw) solid rgba(31, 31, 31, 1);
            padding: 30px;
            margin: 15px 0;
            /* Radial gradient background matching card component */
            background-image: radial-gradient(at top left, #1F1F1F 0%, #0E0E0E 50%);
            overflow: visible;
            z-index: 0;
        }

        /* Column layout support for numbered lists */
        .numbered-list-container[data-columns="1"] .elementor-numbered-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .numbered-list-container[data-columns="2"] .elementor-numbered-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
        }

        .numbered-list-container[data-columns="3"] .elementor-numbered-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px 20px;
        }

        /* Individual numbered list items with solid dark backgrounds matching bulletlist.html */
        .numbered-list-container .elementor-numbered-list-item {
            background-color: #000000;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Numeric text size configuration for numbered list items */
        .numbered-list-container .elementor-numbered-list-text {
            font-size: var(--text-size, 16px);
            line-height: 1.3em;
        }

        .numbered-list-container::before {
            content: "";
            position: absolute;
            inset: calc(-1 * var(--ring-w));
            padding: var(--ring-w);
            border-radius: calc(var(--radius) + var(--ring-w));
            display: block;
            background: linear-gradient(
                to bottom,
                rgba(117, 62, 247, 0.60) 0%,
                rgba(168, 85, 247, 0.40) 16%,
                rgba(168, 85, 247, 0.20) 32%,
                rgba(168, 85, 247, 0.00) 55%
            );
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                    mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            z-index: 1;
            pointer-events: none;
        }
        
        .elementor-numbered-list {
            list-style: none;
            counter-reset: item-counter;
            padding: 0;
            margin: 0;
        }
        
        .elementor-numbered-list-item {
            counter-increment: item-counter;
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            position: relative;
        }
        
        .elementor-numbered-list-item::before {
            content: counter(item-counter);
            background: var(--e-global-color-e850821);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 12px;
            margin-right: 15px;
            flex-shrink: 0;
            margin-top: 2px;
        }
        
        .elementor-numbered-list-text {
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-weight: var(--e-global-typography-text-font-weight);
            color: #FFFFFF;
            font-size: var(--e-global-typography-text-font-size);
            line-height: 1.3em;
        }
        
        /* Horizontal rule styling */
        .elementor-divider {
            margin: 30px 0;
            border: none;
            height: 2px;
            background: linear-gradient(90deg, var(--e-global-color-e850821) 0%, rgba(117, 62, 247, 0.3) 100%);
            border-radius: 2px;
        }
        
        /* Directory tree styling */
        .directory-tree-container {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            font-family: 'Courier New', monospace;
        }
        
        .directory-tree {
            color: #FFFFFF;
            line-height: 1.6;
            white-space: pre;
            font-size: 14px;
        }
        
        .directory-tree .folder {
            color: #FFD700;
            font-weight: 600;
        }
        
        .directory-tree .file {
            color: #87CEEB;
        }
        
        .directory-tree .comment {
            color: #90EE90;
            font-style: italic;
        }
        
        /* Code block styling */
        .code-block-container {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .code-block-header {
            background: rgba(117, 62, 247, 0.2);
            padding: 8px 15px;
            font-family: var(--e-global-typography-text-font-family), Sans-serif;
            font-size: 12px;
            color: #CCCCCC;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .code-block-content {
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: #FFFFFF;
            white-space: pre;
            overflow-x: auto;
            background: rgba(0, 0, 0, 0.2);
        }
        
        /* Inline code styling */
        .inline-code {
            background-color: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #FFFFFF;
        }
        `;

        // Generate unique Elementor IDs
        function generateElementorId() {
            return Math.random().toString(16).substr(2, 8);
        }

        // H1 with gradient styling
        function createH1Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h1 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h1>
</div>`;
        }

        // H2 with same gradient styling as H1
        function createH2Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h2 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h2>
</div>`;
        }

        // H3 with same gradient styling as H1
        function createH3Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h3 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h3>
</div>`;
        }

        // H4 with same gradient styling as H1
        function createH4Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h4 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h4>
</div>`;
        }

        // H5 with same gradient styling as H1
        function createH5Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h5 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h5>
</div>`;
        }

        // H6 with same gradient styling as H1
        function createH6Element(text) {
            const id = generateElementorId();
            // Check for custom anchor {#custom-id}
            const anchorMatch = text.match(/^(.*?)\s*\{#([^}]+)\}$/);
            let displayText, anchorId;
            
            if (anchorMatch) {
                displayText = anchorMatch[1].trim();
                anchorId = anchorMatch[2];
            } else {
                displayText = text;
                anchorId = generateSlug(text.replace(/<[^>]*>/g, ''));
            }
            
            return `<div class="elementor-element elementor-element-${id} elementor-widget__width-initial elementor-widget elementor-widget-heading" data-id="${id}" data-element_type="widget" data-widget_type="heading.default">
    <h6 id="${anchorId}" class="elementor-heading-title elementor-size-default">${displayText}</h6>
</div>`;
        }

        // Paragraph structure
        function createParagraphElement(text) {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
    <div class="elementor-widget-container">
        <p class="elementor-text-editor">${text}</p>
    </div>
</div>`;
        }

        // Blockquote structure
        function createBlockquoteElement(text) {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
    <div class="elementor-widget-container">
        <blockquote class="elementor-blockquote">${parseInlineMarkdown(text)}</blockquote>
    </div>
</div>`;
        }

        // Table structure
        function createTableElement(rows) {
            const id = generateElementorId();
            const tableRows = rows.map((row, index) => {
                const cells = row.map(cell => {
                    const tag = index === 0 ? 'th' : 'td';
                    return `<${tag}>${parseInlineMarkdown(cell)}</${tag}>`;
                }).join('');
                return `<tr>${cells}</tr>`;
            }).join('\n            ');
            
            return `<div class="table-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <table class="elementor-table">
                ${tableRows}
            </table>
        </div>
    </div>
</div>`;
        }

        // Horizontal rule structure
        function createHorizontalRuleElement() {
            const id = generateElementorId();
            return `<div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-divider" data-id="${id}" data-element_type="widget" data-widget_type="divider.default">
    <div class="elementor-widget-container">
        <hr class="elementor-divider">
    </div>
</div>`;
        }

        // Directory tree structure
        function createDirectoryTreeElement(treeContent) {
            const id = generateElementorId();
            
            // Parse and format the directory tree
            const formattedTree = formatDirectoryTree(treeContent);
            
            return `<div class="directory-tree-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <div class="directory-tree">${formattedTree}</div>
        </div>
    </div>
</div>`;
        }

        // Format directory tree with proper coloring
        function formatDirectoryTree(content) {
            return content
                .split('\n')
                .map(line => {
                    // Detect folders (ending with /)
                    if (line.match(/.*\/\s*$/)) {
                        return line.replace(/(.*\/)\s*$/, '<span class="folder">$1</span>');
                    }
                    // Detect comments in parentheses
                    else if (line.includes('(') && line.includes(')')) {
                        return line.replace(/(\([^)]*\))/, '<span class="comment">$1</span>');
                    }
                    // Regular files
                    else if (line.trim() && !line.match(/^[├└│\s]*$/)) {
                        // Extract the filename part (after tree characters)
                        const match = line.match(/^([├└│\s─]*)(.*)/);
                        if (match) {
                            return match[1] + '<span class="file">' + match[2] + '</span>';
                        }
                        return '<span class="file">' + line + '</span>';
                    }
                    return line;
                })
                .join('\n');
        }

        // Code block structure
        function createCodeBlockElement(language, content) {
            const id = generateElementorId();
            
            // Check if the content is a directory tree structure
            const hasTreeChars = content.includes('└') || content.includes('├') || content.includes('│');
            const hasDirectoryStructure = content.match(/.*\/\s*$|.*\.(js|ts|json|md|txt|py|html|css|xml)/) || content.includes('(') && content.includes(')');
            
            if (hasTreeChars && hasDirectoryStructure) {
                // Render as directory tree instead of code block
                return createDirectoryTreeElement(content);
            }
            
            // Clean up the content - remove extra whitespace but preserve internal spacing
            const cleanContent = content.split('\n')
                .map(line => line.replace(/^\s*/, '')) // Remove leading whitespace
                .join('\n')
                .trim();
            
            const languageLabel = language || 'code';
            
            return `<div class="code-block-container">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <div class="code-block-header">${languageLabel}</div>
            <div class="code-block-content">${cleanContent}</div>
        </div>
    </div>
</div>`;
        }

        // Numbered list structure
        function createNumberedListElement(items) {
            const id = generateElementorId();
            const listItems = items.map(item => 
                `<li class="elementor-numbered-list-item">
                    <span class="elementor-numbered-list-text">${item}</span>
                </li>`
            ).join('\n                ');
            
            return `<div class="numbered-list-container" data-columns="1" style="--text-size: 16px;">
    <div class="elementor-element elementor-element-${id} elementor-widget elementor-widget-text-editor" data-id="${id}" data-element_type="widget" data-widget_type="text-editor.default">
        <div class="elementor-widget-container">
            <ol class="elementor-numbered-list">
                ${listItems}
            </ol>
        </div>
    </div>
</div>`;
        }

        // List structure with check-circle icons (non-clickable)
        function createListElement(items) {
            const id = generateElementorId();
            const listItems = items.map(item => 
                `<li class="elementor-icon-list-item">
                    <span class="elementor-icon-list-icon">
                        <svg aria-hidden="true" class="e-font-icon-svg e-far-check-circle" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 48c110.532 0 200 89.451 200 200 0 110.532-89.451 200-200 200-110.532 0-200-89.451-200-200 0-110.532 89.451-200 200-200m140.204 130.267l-22.536-22.718c-4.667-4.705-12.265-4.736-16.97-.068L215.346 303.697l-59.792-60.277c-4.667-4.705-12.265-4.736-16.97-.069l-22.719 22.536c-4.705 4.667-4.736 12.265-.068 16.971l90.781 91.516c4.667 4.705 12.265 4.736 16.97.068l172.589-171.204c4.704-4.668 4.734-12.266.067-16.971z"></path></svg>
                    </span>
                    <span class="elementor-icon-list-text">${item}</span>
                </li>`
            ).join('\n                ');
            
            return `<div class="bullet-list-container" data-columns="1" style="--text-size: 16px;">
    <div class="elementor-element elementor-element-${id} elementor-align-left elementor-icon-list--layout-traditional elementor-widget elementor-widget-icon-list" data-id="${id}" data-element_type="widget" data-widget_type="icon-list.default">
        <ul class="elementor-icon-list-items">
            ${listItems}
        </ul>
    </div>
</div>`;
        }

        function convertToElementorHTML() {
            const markdownInput = document.getElementById('markdownInput').value;
            const htmlOutput = document.getElementById('htmlOutput');
            const outputSection = document.getElementById('outputSection');
            const outputButtons = document.getElementById('outputButtons');

            if (!markdownInput.trim()) {
                htmlOutput.textContent = 'Please enter some markdown content to convert.';
                return;
            }

            try {
                let html = parseMarkdownToElementor(markdownInput);
                
                // Add the CSS
                html = `<style>${elementorCSS}</style>\n\n` + html;
                
                htmlOutput.textContent = html;
                
                // Store for copying
                window.currentHTML = html;

                // Reveal output section and its controls
                if (outputSection) outputSection.style.display = '';
                if (outputButtons) outputButtons.style.display = 'flex';
                const resetBtn = document.getElementById('resetBtn');
                if (resetBtn) resetBtn.style.display = 'inline-block';

                // Smooth scroll to output
                outputSection?.scrollIntoView({ behavior: 'smooth', block: 'start' });

            } catch (error) {
                htmlOutput.textContent = 'Error converting markdown: ' + error.message;
            }
        }

        function resetOutput() {
            const htmlOutput = document.getElementById('htmlOutput');
            htmlOutput.textContent = '';
            window.currentHTML = '';
            const mdInput = document.getElementById('markdownInput');
            if (mdInput) { mdInput.value = ''; mdInput.focus(); }
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) resetBtn.style.display = 'none';
            const outputSection = document.getElementById('outputSection');
            if (outputSection) outputSection.style.display = 'none';
            const outputButtons = document.getElementById('outputButtons');
            if (outputButtons) outputButtons.style.display = 'none';
        }

        function parseInlineMarkdown(text) {
            // Parse inline code (`code`)
            text = text.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
            
            // Parse bold text (**text**)
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Parse italic text (*text*)
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Parse internal links for table of contents [text](#anchor)
            text = text.replace(/\[([^\]]+)\]\(#([^)]+)\)/g, '<a href="#$2">$1</a>');
            
            // Parse regular links [text](url)
            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            return text;
        }

        // Generate slug from header text for anchors
        function generateSlug(text) {
            return text.toLowerCase()
                .replace(/[^\w\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .trim();
        }

        function parseMarkdownToElementor(markdown) {
            const lines = markdown.split('\n');
            const result = [];
            let currentList = [];
            let currentNumberedList = [];
            let currentTable = [];
            let inBlockquote = false;
            let blockquoteContent = '';
            let inDirectoryTree = false;
            let directoryTreeContent = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLanguage = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Handle fenced code blocks (```language)
                if (line.startsWith('```')) {
                    if (!inCodeBlock) {
                        // Starting a code block
                        if (currentList.length > 0) {
                            result.push(createListElement(currentList));
                            currentList = [];
                        }
                        if (currentNumberedList.length > 0) {
                            result.push(createNumberedListElement(currentNumberedList));
                            currentNumberedList = [];
                        }
                        if (currentTable.length > 0) {
                            result.push(createTableElement(currentTable));
                            currentTable = [];
                        }
                        
                        inCodeBlock = true;
                        codeBlockLanguage = line.substring(3).trim(); // Extract language after ```
                        codeBlockContent = '';
                        continue;
                    } else {
                        // Ending a code block
                        result.push(createCodeBlockElement(codeBlockLanguage, codeBlockContent));
                        inCodeBlock = false;
                        codeBlockContent = '';
                        codeBlockLanguage = '';
                        continue;
                    }
                }
                
                // If we're inside a code block, collect all content
                if (inCodeBlock) {
                    codeBlockContent += (codeBlockContent ? '\n' : '') + lines[i]; // Use original line with whitespace
                    continue;
                }
                
                // Handle directory tree structures - much more specific detection
                const isDirectoryLine = (line.includes('└') || line.includes('├') || line.includes('│')) &&
                                       (line.includes('/') || line.match(/\.(js|ts|json|md|txt|py|html|css|xml)$/)) &&
                                       !line.includes('|') && // Not a table
                                       !line.includes('**') && // Not bold text
                                       !line.includes('`'); // Not code
                
                if (isDirectoryLine && !inDirectoryTree) {
                    // Starting a new directory tree - only start if we detect actual tree characters
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    inDirectoryTree = true;
                    directoryTreeContent = lines[i]; // Use original line with whitespace
                    continue;
                }
                
                if (inDirectoryTree) {
                    // Only continue if line has tree characters OR is indented and has folder/file indicators
                    const hasTreeChars = lines[i].includes('└') || lines[i].includes('├') || lines[i].includes('│');
                    const isIndentedPath = lines[i].match(/^\s+.*\/$/) || lines[i].match(/^\s+.*\.(js|ts|json|md|txt|py|html|css|xml)/) || lines[i].match(/^\s+.*\([^)]+\)$/);
                    const continuingTree = hasTreeChars || 
                                          lines[i].trim() === '' || // Allow empty lines in trees
                                          (isIndentedPath && !lines[i].includes('|') && !lines[i].includes('**') && !lines[i].includes('`'));
                    
                    if (continuingTree) {
                        directoryTreeContent += '\n' + lines[i];
                        continue;
                    } else {
                        // End the directory tree
                        result.push(createDirectoryTreeElement(directoryTreeContent));
                        inDirectoryTree = false;
                        directoryTreeContent = '';
                        // Continue processing the current line normally
                    }
                }

                // Handle blockquotes (both "> " and just ">")
                if (line.startsWith('> ') || line.startsWith('>')) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    
                    if (!inBlockquote) {
                        inBlockquote = true;
                        blockquoteContent = '';
                    }
                    
                    // Extract text after > or > 
                    const quoteText = line.startsWith('> ') ? line.substring(2) : line.substring(1);
                    blockquoteContent += (blockquoteContent ? ' ' : '') + quoteText;
                    continue;
                } else if (inBlockquote) {
                    result.push(createBlockquoteElement(blockquoteContent));
                    inBlockquote = false;
                    blockquoteContent = '';
                }
                
                // Handle table rows (skip separator rows like |---|---|)
                if (line.includes('|') && line.split('|').length > 2) {
                    // Skip separator rows that contain only dashes, spaces, and pipes between the outer pipes
                    const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                    const isSeparatorRow = cells.every(cell => /^[\s\-]+$/.test(cell));
                    if (!isSeparatorRow) {
                        if (currentList.length > 0) {
                            result.push(createListElement(currentList));
                            currentList = [];
                        }
                        if (currentNumberedList.length > 0) {
                            result.push(createNumberedListElement(currentNumberedList));
                            currentNumberedList = [];
                        }
                        
                        if (cells.length > 0) {
                            currentTable.push(cells);
                        }
                    }
                    continue;
                } else if (currentTable.length > 0 && !line.includes('|')) {
                    result.push(createTableElement(currentTable));
                    currentTable = [];
                }
                
                // Handle horizontal rules (---)
                if (line.match(/^-{3,}$/)) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    if (currentTable.length > 0) {
                        result.push(createTableElement(currentTable));
                        currentTable = [];
                    }
                    result.push(createHorizontalRuleElement());
                    continue;
                }

                if (!line) {
                    // Process any pending lists or table
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    continue;
                }

                // Headers - Check from most specific (H6) to least specific (H1)
                if (line.match(/^######\s+(.+)$/)) {
                    const match = line.match(/^######\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH6Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^#####\s+(.+)$/)) {
                    const match = line.match(/^#####\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH5Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^####\s+(.+)$/)) {
                    const match = line.match(/^####\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH4Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^###\s+(.+)$/)) {
                    const match = line.match(/^###\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH3Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^##\s+(.+)$/)) {
                    const match = line.match(/^##\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH2Element(parseInlineMarkdown(match[1])));
                    continue;
                } else if (line.match(/^#\s+(.+)$/)) {
                    const match = line.match(/^#\s+(.+)$/);
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    result.push(createH1Element(parseInlineMarkdown(match[1])));
                    continue;
                }

                // Bullet list items
                const bulletMatch = line.match(/^[-*+]\s+(.+)$/);
                if (bulletMatch) {
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    currentList.push(parseInlineMarkdown(bulletMatch[1]));
                    continue;
                }

                // Numbered list items
                const numberedMatch = line.match(/^\d+\.\s+(.+)$/);
                if (numberedMatch) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    currentNumberedList.push(parseInlineMarkdown(numberedMatch[1]));
                    continue;
                }

                // Regular paragraphs
                if (line) {
                    if (currentList.length > 0) {
                        result.push(createListElement(currentList));
                        currentList = [];
                    }
                    if (currentNumberedList.length > 0) {
                        result.push(createNumberedListElement(currentNumberedList));
                        currentNumberedList = [];
                    }
                    
                    result.push(createParagraphElement(parseInlineMarkdown(line)));
                }
            }

            // Process any remaining items
            if (currentList.length > 0) {
                result.push(createListElement(currentList));
            }
            if (currentNumberedList.length > 0) {
                result.push(createNumberedListElement(currentNumberedList));
            }
            if (currentTable.length > 0) {
                result.push(createTableElement(currentTable));
            }
            if (inBlockquote && blockquoteContent) {
                result.push(createBlockquoteElement(blockquoteContent));
            }
            if (inDirectoryTree && directoryTreeContent) {
                result.push(createDirectoryTreeElement(directoryTreeContent));
            }
            if (inCodeBlock && codeBlockContent) {
                result.push(createCodeBlockElement(codeBlockLanguage, codeBlockContent));
            }

            return result.join('\n\n');
        }

        function copyHTML(btn) {
            if (!window.currentHTML) {
                alert('Please convert some markdown first!');
                return;
            }

            navigator.clipboard.writeText(window.currentHTML).then(() => {
                const originalText = btn.textContent;
                const originalBackground = btn.style.background;
                btn.textContent = 'Copied!';
                btn.style.background = '#28a745';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = originalBackground;
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please select and copy manually.');
            });
        }

        // Start with empty output; convert when the user clicks

        // -------- Drag & Drop / Upload for Markdown --------
        async function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function isMarkdownFile(name) {
            return /\.(md|markdown|txt)$/i.test(name);
        }

        async function importSingleFile(file) {
            if (!file || !isMarkdownFile(file.name)) return;
            const mdInput = document.getElementById('markdownInput');
            try {
                const content = await readFileAsText(file);
                const header = `\n\n---\n\n# ${file.name}\n\n`;
                if (mdInput.value) mdInput.value += '\n\n';
                mdInput.value += header + content.trim();
                mdInput.focus();
            } catch (e) {
                console.error('Failed to read file', file?.name, e);
            }
        }

        function setupSingleFileDnD() {
            const section = document.getElementById('markdownSection');
            const dz = document.getElementById('dropzone');
            const fileInput = document.getElementById('mdFile');

            // Drag-over visuals on the section (entire panel active)
            ['dragenter','dragover'].forEach(ev => {
                section.addEventListener(ev, e => {
                    e.preventDefault();
                    e.stopPropagation();
                    dz.classList.add('dragover');
                });
            });
            ;['dragleave','dragend','drop'].forEach(ev => {
                section.addEventListener(ev, e => {
                    e.preventDefault();
                    e.stopPropagation();
                    dz.classList.remove('dragover');
                });
            });
            section.addEventListener('drop', async e => {
                const dt = e.dataTransfer;
                if (!dt) return;
                const file = dt.files && dt.files[0];
                await importSingleFile(file);
            });

            fileInput.addEventListener('change', async e => {
                const file = e.target.files && e.target.files[0];
                await importSingleFile(file);
                e.target.value = '';
            });
        }

        // Initialize single-file drag/drop once DOM is ready
        window.addEventListener('load', setupSingleFileDnD);
    </script>
</body>
</html>